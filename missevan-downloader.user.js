// ==UserScript==
// @name         Missevan LRC/JSON/Audio/Image Subtitle Downloader (Auto Detect + Optional Audio ZIP)
// @namespace    http://tampermonkey.net/
// @version      1.9 // TƒÉng version ƒë·ªÉ d·ªÖ qu·∫£n l√Ω
// @description  T·ª± ƒë·ªông t·∫£i ph·ª• ƒë·ªÅ Missevan (.lrc v√† .json), Audio (.m4a) v√† ·∫¢nh b√¨a (.jpg/.png), h·ªó tr·ª£ t·ª´ng t·∫≠p ho·∫∑c to√†n b·ªô drama. M·∫∑c ƒë·ªãnh t·∫£i audio kh√¥ng n√©n (t√πy ch·ªçn n√©n). C√≥ th·ªÉ t·∫£i th√™m c√°c ·∫£nh ph·ª• li√™n quan ƒë·∫øn sound/drama. ƒê√£ s·ª≠a ƒë·ªïi ƒë·ªÉ ∆∞u ti√™n t·∫£i ·∫£nh b√¨a t·∫≠p ch·∫•t l∆∞·ª£ng cao (covers).
// @author       Thien Truong Dia Cuu
// @match        *://www.missevan.com/*
// @grant        GM_xmlhttpRequest
// @grant        GM_download
// @connect      missevan.com
// @require      https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js
// ==/UserScript==

(function () {
    'use strict';

    const DRAMA_INFO_URL = "https://www.missevan.com/dramaapi/getdrama";
    const SOUND_GET_URL = "https://www.missevan.com/sound/getsound";
    const DANMAKU_GET_URL = "https://www.missevan.com/sound/getdm";
    const SOUND_IMAGES_URL = "https://www.missevan.com/sound/getimages";

    const UI_STATE_KEY = 'missevanDownloaderUIState'; // Key for localStorage

    function getURLParam(key) {
        const url = new URL(window.location.href);
        return url.searchParams.get(key);
    }

    function getDramaIdFromURL() {
        const match = location.pathname.match(/\/mdrama\/(\d+)/);
        return match ? match[1] : null;
    }

    function getSoundIdFromURL() {
        return getURLParam("id");
    }

    function log(msg) {
        const logBox = document.getElementById('logOutput');
        if (!logBox) return;
        const p = document.createElement('p');
        p.textContent = msg;
        logBox.appendChild(p);
        logBox.scrollTop = logBox.scrollHeight;
    }

    function fetchData(url, type = 'json') {
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: "GET",
                url,
                responseType: type,
                onload: res => {
                    if (res.status === 200) {
                        resolve(res.response);
                    } else {
                        reject(`Request failed with status: ${res.status} for URL: ${url}`);
                    }
                },
                onerror: err => reject(`Network error: ${err} for URL: ${url}`)
            });
        });
    }

    /**
     * L·∫•y th√¥ng tin Sound ID, bao g·ªìm t√™n, URL ph·ª• ƒë·ªÅ, URL audio, URL ·∫£nh b√¨a.
     * @param {string} id - Sound ID.
     * @returns {Promise<{name: string, subtitleUrl: string|null, audioUrl: string|null, imageUrl: string|null}>}
     */
    async function getSoundInfo(id) {
        const url = `${SOUND_GET_URL}?soundid=${id}`;
        try {
            const data = await fetchData(url);
            const name = data?.info?.sound?.soundstr || `sound_${id}`;
            const cleanedName = name.replace(/[/\\:*?"<>|]/g, "");
            const subtitleUrl = data?.info?.sound?.subtitle_url || null;

            let audioUrl = null;
            if (data?.info?.sound?.soundurl) {
                if (typeof data.info.sound.soundurl === 'string') {
                    audioUrl = data.info.sound.soundurl;
                } else if (Array.isArray(data.info.sound.soundurl) && data.info.sound.soundurl.length > 0) {
                    audioUrl = data.info.sound.soundurl[0]?.url || null;
                } else if (typeof data.info.sound.soundurl === 'object' && data.info.sound.soundurl !== null) {
                    audioUrl = data.info.sound.soundurl.url || data.info.sound.soundurl.url_1 || null;
                }
            }

            // L·∫•y URL ·∫£nh b√¨a ban ƒë·∫ßu, ∆∞u ti√™n 'covers' n·∫øu l√† m·∫£ng, sau ƒë√≥ ƒë·∫øn 'front_cover'
            let imageUrl = data?.info?.sound?.covers?.[0] || data?.info?.sound?.front_cover || null;

            // *** TH√äM LOGIC CHUY·ªÇN ƒê·ªîI coversmini SANG covers ·ªû ƒê√ÇY ***
            if (imageUrl && imageUrl.includes('/coversmini/')) {
                imageUrl = imageUrl.replace('/coversmini/', '/covers/');
                log(`ƒê√£ chuy·ªÉn ƒë·ªïi URL ·∫£nh (coversmini -> covers): ${imageUrl}`); // Ghi log ƒë·ªÉ b·∫°n th·∫•y s·ª± thay ƒë·ªïi
            }

            return { name: cleanedName, subtitleUrl: subtitleUrl, audioUrl: audioUrl, imageUrl: imageUrl };
        } catch (error) {
            log(`‚ùå L·ªói l·∫•y th√¥ng tin Sound ID ${id}: ${error}`);
            return { name: `sound_${id}`, subtitleUrl: null, audioUrl: null, imageUrl: null };
        }
    }

    /**
     * L·∫•y th√¥ng tin Drama ID, bao g·ªìm t√™n, c√°c Sound ID v√† URL ·∫£nh b√¨a drama.
     * @param {string} dramaId - Drama ID.
     * @returns {Promise<{name: string, ids: string[], imageUrl: string|null}>}
     */
    async function getDramaDetails(dramaId) {
        const url = `${DRAMA_INFO_URL}?drama_id=${dramaId}`;
        try {
            const res = await fetchData(url);
            const name = res?.info?.drama?.name?.replace(/[/\\:*?"<>|]/g, "") || `drama_${dramaId}`;
            const imageUrl = res?.info?.drama?.cover || null; // ·∫¢nh b√¨a c·ªßa Drama
            const ids = new Set();
            for (const type of ['ft', 'music', 'episode']) {
                res?.info?.episodes?.[type]?.forEach(e => e.sound_id && ids.add(e.sound_id));
            }
            return { name, ids: Array.from(ids), imageUrl: imageUrl };
        } catch (error) {
            log(`‚ùå L·ªói l·∫•y th√¥ng tin Drama ID ${dramaId}: ${error}`);
            return { name: `drama_${dramaId}`, ids: [], imageUrl: null };
        }
    }

    /**
     * L·∫•y danh s√°ch URL ·∫£nh b·ªï sung cho m·ªôt Sound ID.
     * D·ª±a tr√™n c·∫•u tr√∫c `getimages.htm` b·∫°n cung c·∫•p.
     * @param {string} soundId - Sound ID.
     * @returns {Promise<string[]>} M·∫£ng c√°c URL ·∫£nh.
     */
    async function getAdditionalSoundImages(soundId) {
        const url = `${SOUND_IMAGES_URL}?soundid=${soundId}`;
        try {
            const data = await fetchData(url);
            // Ki·ªÉm tra c·∫•u tr√∫c ph·∫£n h·ªìi c·ªßa getimages.htm
            if (data?.successVal?.images && Array.isArray(data.successVal.images)) {
                // √Åp d·ª•ng chuy·ªÉn ƒë·ªïi coversmini -> covers cho ·∫£nh b·ªï sung n·∫øu c·∫ßn
                return data.successVal.images.map(imgArray => {
                    let imgUrl = imgArray[0];
                    if (imgUrl && imgUrl.includes('/coversmini/')) {
                        imgUrl = imgUrl.replace('/coversmini/', '/covers/');
                        // log(`ƒê√£ chuy·ªÉn ƒë·ªïi URL ·∫£nh b·ªï sung (coversmini -> covers): ${imgUrl}`); // C√≥ th·ªÉ g√¢y nhi·ªÅu log n·∫øu c√≥ nhi·ªÅu ·∫£nh
                    }
                    return imgUrl;
                }).filter(Boolean); // L·ªçc b·ªè c√°c gi√° tr·ªã null/undefined sau khi chuy·ªÉn ƒë·ªïi
            }
            return [];
        } catch (error) {
            log(`‚ùå L·ªói l·∫•y ·∫£nh b·ªï sung cho Sound ID ${soundId}: ${error}`);
            return [];
        }
    }


    async function parseDanmaku(id) {
        const url = `${DANMAKU_GET_URL}?soundid=${id}`;
        try {
            const xmlText = await fetchData(url, 'text');
            const xml = new DOMParser().parseFromString(xmlText, "text/xml");
            const danmakus = Array.from(xml.querySelectorAll("d"));
            const list = {};
            danmakus.forEach(d => {
                const p = d.getAttribute("p");
                if (!p) return;
                const [stime, mode,, ,,, ,dmid] = p.split(",");
                if (mode === "4") list[dmid] = { stime, text: d.textContent };
            });
            return Object.entries(list).sort(([, a], [, b]) => parseFloat(a.stime) - parseFloat(b.stime));
        } catch (error) {
            log(`‚ùå L·ªói ph√¢n t√≠ch Danmaku cho Sound ID ${id}: ${error}`);
            return [];
        }
    }

    function genLRC(data, title) {
        let out = `[ver:v1.0]\n[nickname:Ê∂õ‰πãÈõ®]\n[ti:${title}]`;
        let prev = "";
        for (const [, d] of data) {
            if (prev === d.stime) {
                out += " " + d.text;
                continue;
            }
            prev = d.stime;
            const [s, ms = "00"] = d.stime.split(".");
            const sec = parseInt(s);
            out += `\n[${String(Math.floor(sec / 60)).padStart(2, '0')}:${String(sec % 60).padStart(2, '0')}.${ms.slice(0, 2)}]${d.text}`;
        }
        return out;
    }

    // Helper function to get file extension from URL
    function getFileExtension(url) {
        try {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            const parts = pathname.split('.');
            if (parts.length > 1) {
                return parts.pop().split('?')[0].toLowerCase();
            }
        } catch (e) {
            // Invalid URL, fallback to default
        }
        return ''; // Default empty if no extension found
    }

    async function processDramaId(dramaId, type = 'lrc') {
        log(`üì• ƒêang x·ª≠ l√Ω drama ID: ${dramaId} (Lo·∫°i: ${type.toUpperCase()})`);
        const { name: dramaName, ids, imageUrl: dramaCoverUrl } = await getDramaDetails(dramaId);

        if (ids.length === 0 && type !== 'image' && type !== 'all-images') {
            log(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Sound ID n√†o cho drama ${dramaId}.`);
        }

        const shouldZipAudio = document.getElementById('zipAudioCheckbox')?.checked ?? false;

        const zip = new JSZip();
        let filesAdded = 0;

        // Special handling for 'audio' type when not zipping
        if (type === 'audio' && !shouldZipAudio) {
            log(`üì¶ ƒêang t·∫£i t·ª´ng file audio cho drama ${dramaName} (kh√¥ng n√©n)...`);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                log(`(${i + 1}/${ids.length}) ƒêang chu·∫©n b·ªã t·∫£i audio Sound ID ${id}...`);
                const soundInfo = await getSoundInfo(id);
                const title = soundInfo.name;
                const audioUrl = soundInfo.audioUrl;

                if (audioUrl) {
                    const extension = getFileExtension(audioUrl) || 'm4a';
                    try {
                        await new Promise((resolve, reject) => {
                             GM_download({
                                url: audioUrl,
                                name: `${dramaName}/${title}.${extension}`,
                                saveAs: false,
                                onload: () => {
                                    log(`‚úÖ ƒê√£ t·∫£i ${title}.${extension}`);
                                    resolve();
                                },
                                onerror: e => {
                                    log(`‚ùå L·ªói t·∫£i Audio ${title}.${extension}: ${e.error || e.message || e}`);
                                    reject(e);
                                }
                            });
                        });
                        filesAdded++;
                    } catch (error) {
                        // Error already logged by GM_download's onerror
                    }
                } else {
                    log(`‚ö†Ô∏è Sound ID ${id}: Kh√¥ng c√≥ URL Audio.`);
                }
            }
            log(`‚úÖ Ho√†n t·∫•t t·∫£i ${filesAdded} file audio cho drama ${dramaName}.`);
            return;
        }

        // --- Handle Image downloads for Drama ---
        if (type === 'image' || type === 'all-images') {
            if (dramaCoverUrl) {
                try {
                    const imgBlob = await fetchData(dramaCoverUrl, 'blob');
                    const extension = getFileExtension(dramaCoverUrl) || 'jpg';
                    zip.file(`${dramaName}_cover.${extension}`, imgBlob);
                    filesAdded++;
                    log(`‚úÖ ƒê√£ th√™m ·∫£nh b√¨a drama v√†o ZIP.`);
                } catch (error) {
                    log(`‚ùå L·ªói t·∫£i ·∫£nh b√¨a drama t·ª´ URL ${dramaCoverUrl}: ${error}`);
                }
            } else {
                log(`‚ö†Ô∏è Kh√¥ng c√≥ URL ·∫£nh b√¨a ch√≠nh cho Drama ${dramaId}.`);
            }
        }

        // Iterate through Sound IDs for other types (LRC, JSON, Audio for ZIP, and additional images)
        for (let i = 0; i < ids.length; i++) {
            const id = ids[i];
            log(`(${i + 1}/${ids.length}) X·ª≠ l√Ω Sound ID ${id}`);

            const soundInfo = await getSoundInfo(id);
            const title = soundInfo.name;

            if (type === 'lrc') {
                const data = await parseDanmaku(id);
                if (data.length) {
                    const lrc = genLRC(data, title);
                    zip.file(`${title}.lrc`, lrc);
                    filesAdded++;
                } else {
                    log(`‚ö†Ô∏è Sound ID ${id}: Kh√¥ng c√≥ d·ªØ li·ªáu Danmaku ƒë·ªÉ t·∫°o LRC.`);
                }
            } else if (type === 'json') {
                const subtitleUrl = soundInfo.subtitleUrl;
                if (subtitleUrl) {
                    try {
                        const jsonData = await fetchData(subtitleUrl, 'json');
                        zip.file(`${title}.json`, JSON.stringify(jsonData, null, 2));
                        filesAdded++;
                    } catch (error) {
                        log(`‚ùå Sound ID ${id}: L·ªói t·∫£i JSON t·ª´ URL ${subtitleUrl}: ${error}`);
                    }
                } else {
                    log(`‚ö†Ô∏è Sound ID ${id}: Kh√¥ng c√≥ URL ph·ª• ƒë·ªÅ JSON.`);
                }
            } else if (type === 'audio' && shouldZipAudio) {
                const audioUrl = soundInfo.audioUrl;
                if (audioUrl) {
                    try {
                        const audioBlob = await fetchData(audioUrl, 'blob');
                        const extension = getFileExtension(audioUrl) || 'm4a';
                        zip.file(`${title}.${extension}`, audioBlob);
                        filesAdded++;
                    } catch (error) {
                        log(`‚ùå Sound ID ${id}: L·ªói t·∫£i Audio ƒë·ªÉ n√©n v√†o ZIP t·ª´ URL ${audioUrl}: ${error}`);
                    }
                } else {
                    log(`‚ö†Ô∏è Sound ID ${id}: Kh√¥ng c√≥ URL Audio.`);
                }
            } else if (type === 'all-images') {
                if (soundInfo.imageUrl) {
                     try {
                        const imgBlob = await fetchData(soundInfo.imageUrl, 'blob');
                        const extension = getFileExtension(soundInfo.imageUrl) || 'jpg';
                        zip.file(`images/${title}_cover.${extension}`, imgBlob);
                        filesAdded++;
                    } catch (error) {
                        log(`‚ùå Sound ID ${id}: L·ªói t·∫£i ·∫£nh b√¨a t·∫≠p t·ª´ URL ${soundInfo.imageUrl}: ${error}`);
                    }
                } else {
                    log(`‚ö†Ô∏è Sound ID ${id}: Kh√¥ng c√≥ URL ·∫£nh b√¨a t·∫≠p.`);
                }

                const additionalImages = await getAdditionalSoundImages(id);
                for (let j = 0; j < additionalImages.length; j++) {
                    const imgUrl = additionalImages[j];
                    try {
                        const imgBlob = await fetchData(imgUrl, 'blob');
                        const extension = getFileExtension(imgUrl) || 'jpg';
                        zip.file(`images/${title}_extra_${j+1}.${extension}`, imgBlob);
                        filesAdded++;
                    } catch (error) {
                        log(`‚ùå Sound ID ${id}: L·ªói t·∫£i ·∫£nh b·ªï sung t·ª´ URL ${imgUrl}: ${error}`);
                    }
                }
            }
        }

        if (filesAdded === 0) {
            log(`‚ö†Ô∏è Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c t·∫°o cho drama n√†y.`);
            return;
        }

        log(`üì¶ ƒêang t·∫°o file ZIP (${filesAdded} files)...`);
        const zipFileName = `${dramaName}_${type}.zip`;
        const blob = await zip.generateAsync({ type: "blob" });
        GM_download({
            url: URL.createObjectURL(blob),
            name: zipFileName,
            saveAs: false,
            onload: () => log(`‚úÖ ƒê√£ t·∫£i ${zipFileName}`),
            onerror: e => log(`‚ùå L·ªói t·∫£i ZIP: ${e.error || e.message || e}`)
        });
    }

    async function processSingleSoundId(soundId, type = 'lrc') {
        log(`üéµ T·∫£i t·ª´ng t·∫≠p v·ªõi Sound ID: ${soundId} (Lo·∫°i: ${type.toUpperCase()})`);

        const soundInfo = await getSoundInfo(soundId);
        const name = soundInfo.name;

        if (type === 'lrc') {
            const data = await parseDanmaku(soundId);
            if (!data.length) {
                return log("‚ö†Ô∏è Kh√¥ng c√≥ ph·ª• ƒë·ªÅ LRC (Danmaku).");
            }
            const lrc = genLRC(data, name);
            const blob = new Blob([lrc], { type: "text/plain" });
            GM_download({
                url: URL.createObjectURL(blob),
                name: `${name}.lrc`,
                saveAs: false,
                onload: () => log(`‚úÖ ƒê√£ t·∫£i ${name}.lrc`),
                onerror: e => log(`‚ùå L·ªói t·∫£i LRC: ${e.error || e.message || e}`)
            });
        } else if (type === 'json') {
            const subtitleUrl = soundInfo.subtitleUrl;
            if (!subtitleUrl) {
                return log("‚ö†Ô∏è Kh√¥ng c√≥ URL ph·ª• ƒë·ªÅ JSON.");
            }
            try {
                const jsonData = await fetchData(subtitleUrl, 'json');
                const jsonString = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([jsonString], { type: "application/json" });
                GM_download({
                    url: URL.createObjectURL(blob),
                    name: `${name}.json`,
                    saveAs: false,
                    onload: () => log(`‚úÖ ƒê√£ t·∫£i ${name}.json`),
                    onerror: e => log(`‚ùå L·ªói t·∫£i JSON: ${e.error || e.message || e}`)
                });
            } catch (error) {
                log(`‚ùå L·ªói t·∫£i ho·∫∑c ph√¢n t√≠ch JSON: ${error}`);
            }
        } else if (type === 'audio') {
            const audioUrl = soundInfo.audioUrl;
            if (!audioUrl) {
                return log("‚ö†Ô∏è Kh√¥ng c√≥ URL Audio.");
            }
            try {
                log(`T·∫£i audio t·ª´: ${audioUrl}`);
                const extension = getFileExtension(audioUrl) || 'm4a';
                GM_download({
                    url: audioUrl,
                    name: `${name}.${extension}`,
                    saveAs: false,
                    onload: () => log(`‚úÖ ƒê√£ t·∫£i ${name}.${extension}`),
                    onerror: e => log(`‚ùå L·ªói t·∫£i Audio: ${e.error || e.message || e}`)
                });
            } catch (error) {
                log(`‚ùå L·ªói t·∫£i Audio: ${error}`);
            }
        } else if (type === 'image') {
            const imageUrl = soundInfo.imageUrl;
            if (!imageUrl) {
                return log("‚ö†Ô∏è Kh√¥ng c√≥ URL ·∫£nh b√¨a cho t·∫≠p n√†y.");
            }
            try {
                log(`T·∫£i ·∫£nh b√¨a t·∫≠p t·ª´: ${imageUrl}`);
                const extension = getFileExtension(imageUrl) || 'jpg';
                GM_download({
                    url: imageUrl,
                    name: `${name}_cover.${extension}`,
                    saveAs: false,
                    onload: () => log(`‚úÖ ƒê√£ t·∫£i ${name}_cover.${extension}`),
                    onerror: e => log(`‚ùå L·ªói t·∫£i ·∫¢nh: ${e.error || e.message || e}`)
                });
            } catch (error) {
                log(`‚ùå L·ªói t·∫£i ·∫¢nh: ${error}`);
            }
        } else if (type === 'all-images') {
            const zip = new JSZip();
            let filesAdded = 0;

            if (soundInfo.imageUrl) {
                try {
                    const imgBlob = await fetchData(soundInfo.imageUrl, 'blob');
                    const extension = getFileExtension(soundInfo.imageUrl) || 'jpg';
                    zip.file(`${name}_cover.${extension}`, imgBlob);
                    filesAdded++;
                    log(`‚úÖ ƒê√£ th√™m ·∫£nh b√¨a t·∫≠p v√†o ZIP.`);
                } catch (error) {
                    log(`‚ùå L·ªói t·∫£i ·∫£nh b√¨a t·∫≠p t·ª´ URL ${soundInfo.imageUrl}: ${error}`);
                }
            } else {
                log(`‚ö†Ô∏è Kh√¥ng c√≥ URL ·∫£nh b√¨a t·∫≠p.`);
            }

            const additionalImages = await getAdditionalSoundImages(soundId);
            for (let j = 0; j < additionalImages.length; j++) {
                const imgUrl = additionalImages[j];
                try {
                    const imgBlob = await fetchData(imgUrl, 'blob');
                    const extension = getFileExtension(imgUrl) || 'jpg';
                    zip.file(`${name}_extra_${j+1}.${extension}`, imgBlob);
                    filesAdded++;
                } catch (error) {
                    log(`‚ùå L·ªói t·∫£i ·∫£nh b·ªï sung t·ª´ URL ${imgUrl}: ${error}`);
                }
            }

            if (filesAdded === 0) {
                log(`‚ö†Ô∏è Kh√¥ng c√≥ file ·∫£nh n√†o ƒë∆∞·ª£c t·∫°o cho t·∫≠p n√†y.`);
                return;
            }

            log(`üì¶ ƒêang t·∫°o file ZIP (${filesAdded} files)...`);
            const zipFileName = `${name}_all_images.zip`;
            const blob = await zip.generateAsync({ type: "blob" });
            GM_download({
                url: URL.createObjectURL(blob),
                name: zipFileName,
                saveAs: false,
                onload: () => log(`‚úÖ ƒê√£ t·∫£i ${zipFileName}`),
                onerror: e => log(`‚ùå L·ªói t·∫£i ZIP: ${e.error || e.message || e}`)
            });
        }
    }


    function createUI() {
        // Remove existing UI if any (for script updates)
        const existingBox = document.getElementById('missevanSubtitleTool');
        if (existingBox) {
            existingBox.remove();
        }

        const box = document.createElement("div");
        box.id = "missevanSubtitleTool";
        // --- ƒêI·ªÄU CH·ªàNH K√çCH TH∆Ø·ªöC V√Ä KI·ªÇU D√ÅNG GIAO DI·ªÜN ·ªû ƒê√ÇY ---
        box.style = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            z-index: 10000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 95vh;
            overflow-y: auto;
            resize: both; /* Cho ph√©p ng∆∞·ªùi d√πng resize */
            min-width: 250px;
            min-height: 200px;
        `;
        // L·∫•y tr·∫°ng th√°i hi·ªÉn th·ªã t·ª´ localStorage
        const uiState = localStorage.getItem(UI_STATE_KEY);
        let isUIHidden = false;
        if (uiState === 'hidden') {
            isUIHidden = true;
            box.style.width = 'fit-content'; // Thu g·ªçn khi ·∫©n
            box.style.height = 'fit-content';
            box.style.overflow = 'hidden';
            box.style.padding = '5px';
        }

        box.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 8px; margin-bottom: 5px;">
                <h3 style="margin: 0; text-align: left; color: #333; font-size: 16px;">
                    üéß Missevan Downloader
                </h3>
                <button id="toggleUIBtn" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #555; padding: 0 5px;">
                    ${isUIHidden ? '‚ñ≤' : '‚ñº'} <!-- Bi·ªÉu t∆∞·ª£ng m≈©i t√™n l√™n/xu·ªëng -->
                </button>
            </div>

            <div id="uiContent" style="display: ${isUIHidden ? 'none' : 'flex'}; flex-direction: column; gap: 10px;">
                <div style="padding: 5px 0; border-bottom: 1px solid #eee;">
                    <input type="checkbox" id="zipAudioCheckbox" style="margin-right: 5px; transform: scale(1.1);">
                    <label for="zipAudioCheckbox" style="font-size: 12px; color: #555; cursor: pointer;">
                        N√©n Audio Drama v√†o ZIP?
                    </label>
                    <p style="font-size: 10px; color: #777; margin: 3px 0 0 20px;">
                        (B·ªè ch·ªçn ƒë·ªÉ t·∫£i t·ª´ng file audio cho Drama)
                    </p>
                </div>

                <div style="display: flex; flex-direction: column; gap: 7px;">
                    <strong style="color: #4CAF50;">T·∫£i TO√ÄN B·ªò Drama (ZIP):</strong>
                    <button id="downloadDramaLrcBtn" class="btn drama-btn green">üì• Drama (LRC)</button>
                    <button id="downloadDramaJsonBtn" class="btn drama-btn blue">üì• Drama (JSON)</button>
                    <button id="downloadDramaAudioBtn" class="btn drama-btn orange">üì• Drama (AUDIO)</button>
                    <button id="downloadDramaImageBtn" class="btn drama-btn light-green">üì∏ Drama b√¨a (·∫¢nh)</button>
                    <button id="downloadDramaAllImagesBtn" class="btn drama-btn gray">üñºÔ∏è Drama t·∫•t c·∫£ ·∫£nh</button>
                </div>

                <div style="display: flex; flex-direction: column; gap: 7px; border-top: 1px solid #eee; padding-top: 10px;">
                    <strong style="color: #FFC107;">T·∫£i T·ª™NG T·∫≠p (Sound ID):</strong>
                    <button id="downloadSoundLrcBtn" class="btn sound-btn yellow">üéµ T·∫≠p (LRC)</button>
                    <button id="downloadSoundJsonBtn" class="btn sound-btn purple">üéµ T·∫≠p (JSON)</button>
                    <button id="downloadSoundAudioBtn" class="btn sound-btn dark-blue">üéµ T·∫≠p (AUDIO)</button>
                    <button id="downloadSoundImageBtn" class="btn sound-btn cyan">üì∏ T·∫≠p b√¨a (·∫¢nh)</button>
                    <button id="downloadSoundAllImagesBtn" class="btn sound-btn teal">üñºÔ∏è T·∫≠p t·∫•t c·∫£ ·∫£nh</button>
                </div>

                <div style="border-top: 1px solid #eee; padding-top: 10px;">
                    <h4 style="margin: 0 0 5px 0; color: #333; font-size: 14px;">Log Output:</h4>
                    <div id="logOutput" style="background:#f9f9f9;border:1px solid #eee;height:120px;overflow-y:auto;padding:5px;font-size:10px;color:#444;border-radius:4px;">
                        S·∫µn s√†ng!
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(box);

        // Add CSS for buttons
        const style = document.createElement('style');
        style.innerHTML = `
            #missevanSubtitleTool .btn {
                color: white;
                padding: 8px 12px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                width: 100%;
                text-align: center;
                transition: background-color 0.2s ease, transform 0.1s ease;
            }
            #missevanSubtitleTool .btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }
            #missevanSubtitleTool .btn:active {
                transform: translateY(0);
                box-shadow: none;
            }

            /* Drama Buttons */
            .drama-btn.green { background-color: #4CAF50; }
            .drama-btn.green:hover { background-color: #45a049; }
            .drama-btn.blue { background-color: #2196F3; }
            .drama-btn.blue:hover { background-color: #1e88e5; }
            .drama-btn.orange { background-color: #FF5722; }
            .drama-btn.orange:hover { background-color: #e64a19; }
            .drama-btn.light-green { background-color: #8BC34A; }
            .drama-btn.light-green:hover { background-color: #7cb342; }
            .drama-btn.gray { background-color: #9E9E9E; }
            .drama-btn.gray:hover { background-color: #7c7c7c; }

            /* Sound Buttons */
            .sound-btn.yellow { background-color: #FFC107; color: #333; }
            .sound-btn.yellow:hover { background-color: #ffb300; }
            .sound-btn.purple { background-color: #9C27B0; }
            .sound-btn.purple:hover { background-color: #8e24aa; }
            .sound-btn.dark-blue { background-color: #607D8B; }
            .sound-btn.dark-blue:hover { background-color: #546e7a; }
            .sound-btn.cyan { background-color: #00BCD4; }
            .sound-btn.cyan:hover { background-color: #00acc1; }
            .sound-btn.teal { background-color: #009688; }
            .sound-btn.teal:hover { background-color: #00796b; }
        `;
        document.head.appendChild(style);

        const dramaId = getDramaIdFromURL();
        const soundId = getSoundIdFromURL();

        if (!dramaId && !soundId) {
            log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Drama ID ho·∫∑c Sound ID tr√™n trang n√†y. Vui l√≤ng truy c·∫≠p trang drama ho·∫∑c t·∫≠p.");
        }

        // Event listener for toggling UI visibility
        const toggleUIBtn = document.getElementById('toggleUIBtn');
        const uiContent = document.getElementById('uiContent');
        const missevanSubtitleTool = document.getElementById('missevanSubtitleTool');

        toggleUIBtn.addEventListener('click', () => {
            const isHidden = uiContent.style.display === 'none';
            if (isHidden) {
                uiContent.style.display = 'flex';
                toggleUIBtn.innerHTML = '‚ñº'; // M≈©i t√™n xu·ªëng
                missevanSubtitleTool.style.width = '280px'; // Kh√¥i ph·ª•c chi·ªÅu r·ªông m·∫∑c ƒë·ªãnh
                missevanSubtitleTool.style.height = 'fit-content'; // Kh√¥i ph·ª•c chi·ªÅu cao t·ª± ƒë·ªông
                missevanSubtitleTool.style.overflow = 'auto'; // Cho ph√©p cu·ªôn l·∫°i
                missevanSubtitleTool.style.padding = '10px';
                localStorage.setItem(UI_STATE_KEY, 'visible');
            } else {
                uiContent.style.display = 'none';
                toggleUIBtn.innerHTML = '‚ñ≤'; // M≈©i t√™n l√™n
                missevanSubtitleTool.style.width = 'fit-content'; // Thu g·ªçn
                missevanSubtitleTool.style.height = 'fit-content';
                missevanSubtitleTool.style.overflow = 'hidden'; // ·∫®n thanh cu·ªôn
                missevanSubtitleTool.style.padding = '5px';
                localStorage.setItem(UI_STATE_KEY, 'hidden');
            }
        });


        document.getElementById('downloadDramaLrcBtn').addEventListener('click', () => {
            if (dramaId) processDramaId(dramaId, 'lrc');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Drama ID.");
        });
        document.getElementById('downloadDramaJsonBtn').addEventListener('click', () => {
            if (dramaId) processDramaId(dramaId, 'json');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Drama ID.");
        });
        document.getElementById('downloadDramaAudioBtn').addEventListener('click', () => {
            if (dramaId) processDramaId(dramaId, 'audio');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Drama ID.");
        });
        document.getElementById('downloadDramaImageBtn').addEventListener('click', () => {
            if (dramaId) processDramaId(dramaId, 'image');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Drama ID.");
        });
        document.getElementById('downloadDramaAllImagesBtn').addEventListener('click', () => {
            if (dramaId) processDramaId(dramaId, 'all-images');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Drama ID.");
        });

        document.getElementById('downloadSoundLrcBtn').addEventListener('click', () => {
            if (soundId) processSingleSoundId(soundId, 'lrc');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Sound ID. Vui l√≤ng truy c·∫≠p trang t·ª´ng t·∫≠p.");
        });
        document.getElementById('downloadSoundJsonBtn').addEventListener('click', () => {
            if (soundId) processSingleSoundId(soundId, 'json');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Sound ID. Vui l√≤ng truy c·∫≠p trang t·ª´ng t·∫≠p.");
        });
        document.getElementById('downloadSoundAudioBtn').addEventListener('click', () => {
            if (soundId) processSingleSoundId(soundId, 'audio');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Sound ID. Vui l√≤ng truy c·∫≠p trang t·ª´ng t·∫≠p.");
        });
        document.getElementById('downloadSoundImageBtn').addEventListener('click', () => {
            if (soundId) processSingleSoundId(soundId, 'image');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Sound ID. Vui l√≤ng truy c·∫≠p trang t·ª´ng t·∫≠p.");
        });
        document.getElementById('downloadSoundAllImagesBtn').addEventListener('click', () => {
            if (soundId) processSingleSoundId(soundId, 'all-images');
            else log("‚ùå Kh√¥ng t√¨m th·∫•y Sound ID. Vui l√≤ng truy c·∫≠p trang t·ª´ng t·∫≠p.");
        });
    }

    // Initialize UI
    window.addEventListener('load', createUI);

})();
